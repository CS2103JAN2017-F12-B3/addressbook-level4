# A0140032E
###### /java/seedu/taskmanager/commons/events/model/TaskManagerChangedEvent.java
``` java
    public final String commandText;

    public TaskManagerChangedEvent(ReadOnlyTaskManager data, String commandText) {
        this.data = data;
        this.commandText = commandText;
    }
```
###### /java/seedu/taskmanager/commons/util/StringUtil.java
``` java
    private static final int TOLERANCE_SIMPLE_RATIO = 90;
    private static final int TOLERANCE_PARTIAL_RATIO = 90;
    private static final int TOLERANCE_TOKEN_SORT_PARTIAL_RATIO = 80;
    private static final int TOLERANCE_TOKEN_SORT_RATIO = 90;
```
###### /java/seedu/taskmanager/commons/util/StringUtil.java
``` java
        int simpleRatio = FuzzySearch.ratio(preppedSentence, preppedWord);
        int partialRatio = FuzzySearch.partialRatio(preppedSentence, preppedWord);
        int tokenSortPartialRatio = FuzzySearch.tokenSortPartialRatio(preppedSentence, preppedWord);
        int tokenSortRatio = FuzzySearch.tokenSortRatio(preppedSentence, preppedWord);
        if (simpleRatio >= TOLERANCE_SIMPLE_RATIO ||
                partialRatio >= TOLERANCE_PARTIAL_RATIO ||
                tokenSortPartialRatio >= TOLERANCE_TOKEN_SORT_PARTIAL_RATIO ||
                tokenSortRatio >= TOLERANCE_TOKEN_SORT_RATIO) {
            return true;
        }
```
###### /java/seedu/taskmanager/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_DATE_ORDER_CONSTRAINTS = "Start Date should be earlier or same as End Date";
    public static final String MESSAGE_REPEAT_WITH_START_DATE_CONSTRAINTS = "Recurring tasks should have a start date";
    public static final String TIME_OF_DAY_START = " 00:00am";
    public static final String TIME_OF_DAY_END = " 11:59pm";
```
###### /java/seedu/taskmanager/logic/commands/AddCommand.java
``` java
        // Enforce start date before end date
        if (startDate.isPresent() && endDate.isPresent()) {
            StartDate sd = new StartDate(startDate.get());
            EndDate ed = new EndDate(endDate.get());
            // Enforce tasks with inferred times are set to appropriate times
            if (sd.after(ed) && ed.isTimeInferred()) {
                endDate = Optional.of(endDate.get() + TIME_OF_DAY_END);
            } else if (sd.after(ed) && sd.isTimeInferred()) {
                startDate = Optional.of(startDate.get() + TIME_OF_DAY_START);
            }
            sd = new StartDate(startDate.get());
            ed = new EndDate(endDate.get());
            if (sd.after(ed)) {
                throw new IllegalValueException(MESSAGE_DATE_ORDER_CONSTRAINTS);
            }
        }

        // Enforce recurring tasks have start date
        if (repeat.isPresent() && !startDate.isPresent()) {
            throw new IllegalValueException(MESSAGE_REPEAT_WITH_START_DATE_CONSTRAINTS);
        }

        this.toAdd = new Task(new Title(title),
                startDate.isPresent() && !startDate.get().trim().equals("")
                        ? Optional.of(new StartDate(startDate.get())) : Optional.empty(),
                endDate.isPresent() && !endDate.get().trim().equals("") ? Optional.of(new EndDate(endDate.get()))
                        : Optional.empty(),
                description.isPresent() && !description.get().trim().equals("")
                        ? Optional.of(new Description(description.get())) : Optional.empty(),
                repeat.isPresent() && !repeat.get().trim().equals("") ? Optional.of(new Repeat(repeat.get()))
                        : Optional.empty(),
                new Status(), new UniqueTagList(tagSet));
```
###### /java/seedu/taskmanager/logic/commands/AddCommand.java
``` java
    public Task getTask() {
        return this.toAdd;
    }
```
###### /java/seedu/taskmanager/logic/commands/DoneCommand.java
``` java
            } else {
                // Extract a recurring task and mark as done
                Task markedDoneTask = createDoneTask(taskToMarkDone);
                Task updatedRecurringTask = updateRecurringTask(taskToMarkDone);
                try {
                    if (updatedRecurringTask != null) {
                        model.updateTask(targetIndex - 1, updatedRecurringTask);
                        model.addTask(markedDoneTask);
                    } else {
                        model.updateTask(targetIndex - 1, markedDoneTask);
                    }
                } catch (UniqueTaskList.DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
```
###### /java/seedu/taskmanager/logic/commands/DoneCommand.java
``` java
    private static Task updateRecurringTask(ReadOnlyTask recurringTask) {
        assert recurringTask != null;

        Title updatedTitle = recurringTask.getTitle();

        RepeatPattern rp = recurringTask.getRepeat().get().pattern;
        DateTime startDate = new DateTime(recurringTask.getStartDate().get());
        switch (rp) {
        case DAY:
            startDate = startDate.plusDays(1);
            break;
        case MONTH:
            startDate = startDate.plusMonths(1);
            break;
        case WEEK:
            startDate = startDate.plusWeeks(1);
            break;
        case YEAR:
            startDate = startDate.plusYears(1);
            break;
        default:
            break;
        }

        Optional<StartDate> updatedStartDate = Optional.of(new StartDate(startDate));
        Optional<EndDate> updatedEndDate = recurringTask.getEndDate();

        if (updatedStartDate.isPresent() && updatedEndDate.isPresent()
                && updatedStartDate.get().after(updatedEndDate.get())) {
            return null;
        }

        Optional<Description> updatedDescription = recurringTask.getDescription();
        Optional<Repeat> updatedRepeat = recurringTask.getRepeat();
        Status updatedStatus = new Status(false);
        UniqueTagList updatedTags = recurringTask.getTags();

        return new Task(updatedTitle, updatedStartDate, updatedEndDate, updatedDescription, updatedRepeat,
                updatedStatus, updatedTags);
    }
}
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
    public static final String MESSAGE_DATE_ORDER_CONSTRAINTS = "Start Date should be earlier or same as End Date";
    public static final String MESSAGE_REPEAT_WITH_START_DATE_CONSTRAINTS = "Recurring tasks should have a start date";
    public static final String MESSAGE_REPEAT_WITH_DONE_CONSTRAINTS = "Completed tasks cannot have any repeat patterns";
    public static final String TIME_OF_DAY_START = " 00:00am";
    public static final String TIME_OF_DAY_END = " 11:59pm";
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        // Enforce start date before end date
        try {
            if (editedTask.getStartDate().isPresent() && editedTask.getEndDate().isPresent()) {
                StartDate sd = editedTask.getStartDate().get();
                EndDate ed = editedTask.getEndDate().get();
                if (sd.after(ed) && ed.isTimeInferred()) {
                    editedTask.setEndDate(Optional.of(new EndDate(ed.toDateString() + TIME_OF_DAY_END)));
                } else if (sd.after(ed) && sd.isTimeInferred()) {
                    editedTask.setStartDate(Optional.of(new StartDate(sd.toDateString() + TIME_OF_DAY_START)));
                }
                if (editedTask.getStartDate().get().after(editedTask.getEndDate().get())) {
                    throw new CommandException(MESSAGE_DATE_ORDER_CONSTRAINTS);
                }
            }
        } catch (IllegalValueException ive) {
            throw new CommandException(ive.getMessage());
        }

        // Enforce recurring tasks have start date
        if (editedTask.getRepeat().isPresent() && !editedTask.getStartDate().isPresent()) {
            throw new CommandException(MESSAGE_REPEAT_WITH_START_DATE_CONSTRAINTS);
        }

        // Enforce completed tasks do not have any recurrence
        if (editedTask.getRepeat().isPresent() && editedTask.getStatus().value) {
            throw new CommandException(MESSAGE_REPEAT_WITH_DONE_CONSTRAINTS);
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        Optional<StartDate> updatedStartDate = editTaskDescriptor.isStartDateChanged()
                ? editTaskDescriptor.getStartDate() : taskToEdit.getStartDate();
        Optional<EndDate> updatedEndDate = editTaskDescriptor.isEndDateChanged() ? editTaskDescriptor.getEndDate()
                : taskToEdit.getEndDate();
        Optional<Description> updatedDescription = editTaskDescriptor.isDescriptionChanged()
                ? editTaskDescriptor.getDescription() : taskToEdit.getDescription();
        Optional<Repeat> updatedRepeat = editTaskDescriptor.isRepeatChanged() ? editTaskDescriptor.getRepeat()
                : taskToEdit.getRepeat();
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        private boolean anyChangesMade;
        private boolean startDateChanged;
        private boolean endDateChanged;
        private boolean descriptionChanged;
        private boolean repeatChanged;

        public EditTaskDescriptor() {
            anyChangesMade = false;
            startDateChanged = false;
            endDateChanged = false;
            descriptionChanged = false;
            repeatChanged = false;
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.title = toCopy.getTitle();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getEndDate();
            this.description = toCopy.getDescription();
            this.repeat = toCopy.getRepeat();
            this.status = toCopy.getStatus();
            this.tags = toCopy.getTags();
            this.anyChangesMade = toCopy.isAnyFieldEdited();
            this.startDateChanged = toCopy.isStartDateChanged();
            this.endDateChanged = toCopy.isEndDateChanged();
            this.descriptionChanged = toCopy.isDescriptionChanged();
            this.repeatChanged = toCopy.isRepeatChanged();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return anyChangesMade;
        }

        public void setTitle(Optional<Title> title) {
            assert title != null;
            this.title = title;
            anyChangesMade = true;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setStartDate(Optional<StartDate> startDate) {
            assert startDate != null;
            this.startDate = startDate;
            startDateChanged = true;
            anyChangesMade = true;
        }

        public boolean isStartDateChanged() {
            return startDateChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setEndDate(Optional<EndDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
            anyChangesMade = true;
            endDateChanged = true;
        }

        public boolean isEndDateChanged() {
            return endDateChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
            anyChangesMade = true;
            descriptionChanged = true;
        }

        public boolean isDescriptionChanged() {
            return descriptionChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
            anyChangesMade = true;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setRepeat(Optional<Repeat> repeat) {
            assert repeat != null;
            this.repeat = repeat;
            anyChangesMade = true;
            repeatChanged = true;
        }

        public boolean isRepeatChanged() {
            return repeatChanged;
        }

        public Optional<Repeat> getRepeat() {
            return repeat;
        }

```
###### /java/seedu/taskmanager/logic/commands/FindDateCommand.java
``` java
/**
 * Finds and lists all tasks in task manager which fall in the date(s) range
 * requirements.
 */
public class FindDateCommand extends Command {

    private boolean isRange;
    private Date startDateRange, endDateRange;

    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy");
    private static final SimpleDateFormat sdfInput = new SimpleDateFormat("dd/MM/yyyy");

    public static final String COMMAND_WORD = "findbydate";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all non-floating tasks which is within "
            + "the specified date or date range and displays them as a list with index numbers.\n"
            + "Parameters: DATE [to DATE]\n" + "Example: " + COMMAND_WORD + " 12/03/2017\n" + COMMAND_WORD
            + "10/03/2017 to 15/03/2017";
    public static final String MESSAGE_INVALID_RANGE = "Invalid date range. "
            + "Either provide a single date or a starting date to ending date";
    public static final String MESSAGE_SUCCESS_DATE = "Finding tasks on %1$s\n%2$s";
    public static final String MESSAGE_SUCCESS_DATE_TO_DATE = "Finding tasks from %1$s to %2$s\n%3$s";

    public FindDateCommand(String date) throws IllegalValueException {
        isRange = false;
        try {
            startDateRange = new Date(sdfInput.parse(date).getTime());
        } catch (ParseException e) {
            Parser parser = new Parser();
            List<DateGroup> dateGroups = parser.parse(date);

            if (!dateGroups.isEmpty() && !dateGroups.get(0).getDates().isEmpty()) {
                startDateRange = dateGroups.get(0).getDates().get(0);
            } else {
                throw new IllegalValueException(MESSAGE_INVALID_RANGE);
            }

        }

    }

    public FindDateCommand(String startDate, String endDate) throws IllegalValueException {
        isRange = true;

        try {
            startDateRange = new Date(sdfInput.parse(startDate).getTime());
        } catch (ParseException e) {
            Parser parser = new Parser();
            List<DateGroup> dateGroups = parser.parse(startDate);

            if (!dateGroups.isEmpty() && !dateGroups.get(0).getDates().isEmpty()) {
                startDateRange = dateGroups.get(0).getDates().get(0);
            } else {
                throw new IllegalValueException(MESSAGE_INVALID_RANGE);
            }
        }

        try {
            endDateRange = new Date(sdfInput.parse(endDate).getTime());
        } catch (ParseException e) {
            Parser parser = new Parser();
            List<DateGroup> dateGroups = parser.parse(endDate);

            if (!dateGroups.isEmpty() && !dateGroups.get(0).getDates().isEmpty()) {
                endDateRange = dateGroups.get(0).getDates().get(0);
            } else {
                throw new IllegalValueException(MESSAGE_INVALID_RANGE);
            }
        }

        if (startDateRange.after(endDateRange)) {
            Date temp = startDateRange;
            startDateRange = endDateRange;
            endDateRange = temp;
        }

    }

    @Override
    public CommandResult execute() throws CommandException {
        if (isRange) {
            model.updateFilteredTaskList(startDateRange, endDateRange);
            return new CommandResult(String.format(MESSAGE_SUCCESS_DATE_TO_DATE, sdfOutput.format(startDateRange),
                    sdfOutput.format(endDateRange),
                    getMessageForTaskListShownSummary(model.getFilteredTaskList().size())));
        } else {
            model.updateFilteredTaskList(startDateRange);
            return new CommandResult(String.format(MESSAGE_SUCCESS_DATE, sdfOutput.format(startDateRange),
                    getMessageForTaskListShownSummary(model.getFilteredTaskList().size())));
        }
    }
}
```
###### /java/seedu/taskmanager/logic/commands/RedoCommand.java
``` java
public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_SUCCESS = "Redo successful: %1$s";
    public static final String MESSAGE_NO_MORE_REDO = "No more actions available to redo";

    @Override
    public CommandResult execute() throws CommandException {
        HistoryManager historyManager = HistoryManager.getInstance();
        String commandText;
        try {
            commandText = historyManager.redo();
        } catch (Exception e) {
            throw new CommandException(MESSAGE_NO_MORE_REDO);
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, commandText));
    }

}
```
###### /java/seedu/taskmanager/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command {
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successful: %1$s";
    public static final String MESSAGE_NO_MORE_UNDO = "No more actions available to undo";

    @Override
    public CommandResult execute() throws CommandException {
        HistoryManager historyManager = HistoryManager.getInstance();
        String commandText;
        try {
            commandText = historyManager.undo();
            //highlightChanges(commandText);
        } catch (Exception e) {
            throw new CommandException(MESSAGE_NO_MORE_UNDO);
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, commandText));
    }
}
```
###### /java/seedu/taskmanager/logic/Logic.java
``` java
    void init(Model model, Storage storage);

    String getCommandText();
```
###### /java/seedu/taskmanager/logic/LogicManager.java
``` java
    private static LogicManager instance = null;
    private Model model;
    private Parser parser;
    private Storage storage;
    private String commandText;

    // Singleton pattern
    private LogicManager() {
    }

    public static LogicManager getInstance() {
        if (instance == null) {
            instance = new LogicManager();
        }
        return instance;
    }

    public void init(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
        this.parser = new Parser();
    }

    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        this.commandText = commandText;
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        command.setStorage(storage);
        return command.execute();
    }
```
###### /java/seedu/taskmanager/logic/LogicManager.java
``` java
    public String getCommandText() {
        return this.commandText;
    }
```
###### /java/seedu/taskmanager/logic/parser/CliSyntax.java
``` java
    public static final Prefix PREFIX_REPEAT = new Prefix("r/");
```
###### /java/seedu/taskmanager/logic/parser/EditCommandParser.java
``` java
            if (argsTokenizer.getValue(PREFIX_REPEAT).isPresent()) {
                editTaskDescriptor.setRepeat(ParserUtil.parseRepeat(argsTokenizer.getValue(PREFIX_REPEAT)));
            }
```
###### /java/seedu/taskmanager/logic/parser/FindDateCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindDateCommand object
 */
public class FindDateCommandParser {
    private static final int MIN_NO_OF_DATES = 1;
    private static final int MAX_NO_OF_DATES = 2;

    public Command parse(String args) {

        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindDateCommand.MESSAGE_USAGE));
        }
        args = args.trim();
        String[] dates = args.split(" to ");
        if (dates.length < MIN_NO_OF_DATES || dates.length > MAX_NO_OF_DATES) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindDateCommand.MESSAGE_USAGE));
        }
        try {
            if (dates.length == 1) {
                return new FindDateCommand(dates[0]);
            } else {
                return new FindDateCommand(dates[0], dates[1]);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### /java/seedu/taskmanager/logic/parser/ParserUtil.java
``` java
    public static Optional<StartDate> parseStartDate(Optional<String> startDate) throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() && !startDate.get().trim().equals("") ? Optional.of(new StartDate(startDate.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> description} into an
     * {@code Optional<Description>} if {@code description} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() && !description.get().trim().equals("")
                ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> endDate} into an
     * {@code Optional<EndDate>} if {@code endDate} is present.
     */
    public static Optional<EndDate> parseEndDate(Optional<String> endDate) throws IllegalValueException {
        assert endDate != null;
        return endDate.isPresent() && !endDate.get().trim().equals("") ? Optional.of(new EndDate(endDate.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> repeat} into an
     * {@code Optional<Repeat>} if {@code repeat} is present.
     */
    public static Optional<Repeat> parseRepeat(Optional<String> repeat) throws IllegalValueException {
        assert repeat != null;
        return repeat.isPresent() && !repeat.get().trim().equals("") ? Optional.of(new Repeat(repeat.get()))
                : Optional.empty();
    }
```
###### /java/seedu/taskmanager/MainApp.java
``` java
        history = HistoryManager.getInstance();

        history.init(model);

        logic = LogicManager.getInstance();

        logic.init(model, storage);
```
###### /java/seedu/taskmanager/model/HistoryManager.java
``` java
/**
 * Represents the History of user commands in this session
 */
public class HistoryManager extends ComponentManager {

    private static HistoryManager instance = null;

    private static final int OFFSET_ONE_INDEX = -1;
    private static final int INVALID_INDEX = -1;
    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

    private Model model;
    private ArrayList<HistoryNode> historyList;
    private ArrayList<HistoryNode> futureList;
    private ArrayList<String> historyCommands;
    private ArrayList<String> futureCommands;

    protected HistoryManager() {
        super();

        historyList = new ArrayList<HistoryNode>();
        futureList = new ArrayList<HistoryNode>();
        historyCommands = new ArrayList<String>();
        futureCommands = new ArrayList<String>();
    }

    public static HistoryManager getInstance() {
        if (instance == null) {
            instance = new HistoryManager();
        }
        return instance;
    }

    public void init(Model model) {
        this.model = model;
        TaskManager taskManager = new TaskManager(model.getTaskManager());
        historyList.add(new HistoryNode(taskManager, INVALID_INDEX, INVALID_INDEX));
    }

    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        TaskManager taskManager = new TaskManager(event.data);
        String commandText = new String(event.commandText);
        historyList.add(new HistoryNode(taskManager, INVALID_INDEX, parseIndex(commandText)));

        if (!commandText.equals(RedoCommand.COMMAND_WORD) && !commandText.equals(UndoCommand.COMMAND_WORD)) {
            historyCommands.add(commandText);
        }
        if (!(commandText.equals(RedoCommand.COMMAND_WORD) || commandText.equals(UndoCommand.COMMAND_WORD))) {
            futureList.clear();
            futureCommands.clear();
        }
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                ("Local data changed, updating history manager. Histories = " + historyList.size() + " Futures = "
                        + futureList.size())));
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        if (!event.isSelectCommand) {
            historyList.get(historyList.size() - 1).setHighlightedIndex(event.targetIndex);
        }
    }

    @Subscribe
    public void handleTaskManagerStorageDirectoryChangedEvent(TaskManagerStorageDirectoryChangedEvent event) {
        reset();
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                ("Storage file location changed, resetting history. Histories = " + historyList.size() + " Futures = "
                        + futureList.size())));
    }

    public void reset() {
        historyList.clear();
        futureList.clear();
        historyCommands.clear();
        futureCommands.clear();
    }

    private HistoryItem getMostRecentHistory() {
        if (historyList.size() < 2) {
            throw new NullPointerException();
        }
        HistoryNode historyNode = historyList.remove(historyList.size() - 1);
        futureList.add(new HistoryNode(historyNode));
        String commandText = historyCommands.remove(historyCommands.size() - 1);
        futureCommands.add(new String(commandText));
        int indexToHighlight = historyNode.getParsedIndex() >= 0 ? historyNode.getParsedIndex()
                : historyList.get(historyList.size() - 1).getHighlightedIndex();
        HistoryItem history = new HistoryItem(historyList.remove(historyList.size() - 1), commandText,
                indexToHighlight);
        return history;
    }

    private HistoryItem getMostRecentFuture() {
        if (futureList.size() < 1) {
            throw new NullPointerException();
        }
        String commandText = futureCommands.remove(futureCommands.size() - 1);
        historyCommands.add(new String(commandText));
        HistoryNode historyNode = futureList.remove(futureList.size() - 1);
        HistoryItem history = new HistoryItem(historyNode, commandText, historyNode.getHighlightedIndex());
        return history;
    }

    public String undo() {
        HistoryItem t = getMostRecentHistory();
        model.resetData(t.getHistoryNode().getReadOnlyTaskManager());
        model.indicateJumpToListRequestEvent(t.getIndexToHighlight());
        return t.getCommandText();
    }

    public String redo() {
        HistoryItem t = getMostRecentFuture();
        model.resetData(t.getHistoryNode().getReadOnlyTaskManager());
        model.indicateJumpToListRequestEvent(t.getIndexToHighlight());
        return t.getCommandText();
    }

    private int parseIndex(String args) {
        String[] splitted = args.split(" ");
        try {
            if (splitted[0].equals(AddCommand.COMMAND_WORD)) {
                return INVALID_INDEX;
            }
            return Integer.parseInt(splitted[1]) + OFFSET_ONE_INDEX;
        } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
            return INVALID_INDEX;
        }
    }
}

class HistoryItem {
    private HistoryNode historyNode;
    private String commandText;
    private int indexToHighlight;

    public HistoryItem(HistoryNode historyNode, String text, int indexToHighlight) {
        this.historyNode = historyNode;
        commandText = text;
        this.indexToHighlight = indexToHighlight;
    }

    public HistoryNode getHistoryNode() {
        return historyNode;
    }

    public String getCommandText() {
        return commandText;
    }

    public int getIndexToHighlight() {
        return indexToHighlight;
    }
}

class HistoryNode {
    private ReadOnlyTaskManager taskManager;
    private int highlightedIndex;
    private int parsedIndex;

    public HistoryNode(ReadOnlyTaskManager tm, int highlightedIndex, int parsedIndex) {
        taskManager = tm;
        this.highlightedIndex = highlightedIndex;
        this.parsedIndex = parsedIndex;
    }

    public HistoryNode(HistoryNode historyNode) {
        this.taskManager = historyNode.taskManager;
        this.highlightedIndex = historyNode.highlightedIndex;
        this.parsedIndex = historyNode.parsedIndex;
    }

    public ReadOnlyTaskManager getReadOnlyTaskManager() {
        return taskManager;
    }

    public int getHighlightedIndex() {
        return highlightedIndex;
    }

    public int getParsedIndex() {
        return parsedIndex;
    }

    public void setHighlightedIndex(int highlightedIndex) {
        this.highlightedIndex = highlightedIndex;
    }
}
```
###### /java/seedu/taskmanager/model/Model.java
``` java
    /**
     * Updates the filter of the filtered task list to filter by the given
     * date(s)
     */
    void updateFilteredTaskList(Date date);

    void updateFilteredTaskList(Date startDateCriteria, Date endDateCriteria);
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Date date) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(date)));

    }

    @Override
    public void updateFilteredTaskList(Date startDateCriteria, Date endDateCriteria) {
        updateFilteredTaskList(new PredicateExpression(new DateRangeQualifier(startDateCriteria, endDateCriteria)));

    }
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
        public boolean run(ReadOnlyTask task) {
            boolean hasName = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getTitle().value, keyword)).findAny()
                    .isPresent();
            boolean hasDescription = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(
                            task.getDescription().isPresent() ? task.getDescription().get().value : "", keyword))
                    .findAny().isPresent();
            boolean hasTag = false;
            UniqueTagList tagList = task.getTags();
            for (Tag tag : tagList) {
                hasTag = hasTag || nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(tag.tagName, keyword)).findAny()
                        .isPresent();
            }
            return hasName || hasDescription || hasTag;
        }
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private LocalDate date;

        DateQualifier(Date date) {
            this.date = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            LocalDate taskStartDate = task.getStartDate().isPresent()
                    ? task.getStartDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;
            LocalDate taskEndDate = task.getEndDate().isPresent()
                    ? task.getEndDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;

            boolean isFloatingTask = !(task.getStartDate().isPresent() || task.getEndDate().isPresent());
            if (isFloatingTask) {
                return false;
            }
            if (task.getStartDate().isPresent() && task.getEndDate().isPresent()) {

                return !(taskStartDate.isAfter(date) || taskEndDate.isBefore(date));
            }
            if (task.getStartDate().isPresent()) {
                return !(taskStartDate.isAfter(date));
            }
            return !(taskEndDate.isBefore(date));
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class DateRangeQualifier implements Qualifier {
        private LocalDate startDateCriteria, endDateCriteria;

        DateRangeQualifier(Date startDateCriteria, Date endDateCriteria) {
            this.startDateCriteria = startDateCriteria.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
            this.endDateCriteria = endDateCriteria.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            // tasks must have a starting and ending date in order to qualify
            // for check
            if (!(task.getStartDate().isPresent() && task.getEndDate().isPresent())) {
                return false;
            }

            LocalDate taskStartDate = task.getStartDate().get().toInstant().atZone(ZoneId.systemDefault())
                    .toLocalDate();
            LocalDate taskEndDate = task.getEndDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();

            return !(taskStartDate.isBefore(startDateCriteria) || endDateCriteria.isBefore(taskEndDate));
        }

        @Override
        public String toString() {
            return "date range=" + startDateCriteria.toString() + " to " + endDateCriteria.toString();
        }
    }
```
###### /java/seedu/taskmanager/model/task/EndDate.java
``` java
    public static final LocalTime WORKING_HOUR_END = new LocalTime(18, 0);

    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy h:mm a");
    private static final SimpleDateFormat sdfOutputForDateString = new SimpleDateFormat("d MMM yyyy");
    private static final SimpleDateFormat sdfInput = new SimpleDateFormat("dd/MM/yyyy");
    private static final SimpleDateFormat sdfOutputForStorage = new SimpleDateFormat("d MMM yyyy h:mm a");
    private static boolean timeInferred;

    /**
     * Validates given end date.
     *
     * @throws IllegalValueException
     *             if given end date string is invalid.
     */
    public EndDate(String endDate) throws IllegalValueException {
        super(endDateConstructor(endDate));
    }

    private static long endDateConstructor(String endDate) throws IllegalValueException {
        try {
            return sdfInput.parse(endDate).getTime();
        } catch (ParseException e) {
            try {
                Parser parser = new Parser();
                List<DateGroup> dateGroups = parser.parse(endDate);
                Date parsedDate = dateGroups.get(0).getDates().get(0);
                timeInferred = dateGroups.get(0).isTimeInferred();
                if (timeInferred) {
                    DateTime dt = new DateTime(parsedDate);
                    dt = dt.withTime(WORKING_HOUR_END);
                    return dt.getMillis();
                }
                return dateGroups.get(0).getDates().get(0).getTime();
            } catch (IndexOutOfBoundsException f) {
                throw new IllegalValueException(MESSAGE_ENDDATE_CONSTRAINTS);
            }
        }
    }
```
###### /java/seedu/taskmanager/model/task/EndDate.java
``` java
    @Override
    public String toString() {
        return sdfOutput.format(this);
    }

    public String toStorageString() {
        return sdfOutputForStorage.format(this);
    }

    public String toDateString() {
        return sdfOutputForDateString.format(this);
    }
```
###### /java/seedu/taskmanager/model/task/EndDate.java
``` java
    public boolean isTimeInferred() {
        return timeInferred;
    }
```
###### /java/seedu/taskmanager/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     * This ignores the Task that is DONE from consideration of being in the same state.
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getTitle().equals(this.getTitle()) // state checks here onwards
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate())
```
###### /java/seedu/taskmanager/model/task/ReadOnlyTask.java
``` java
                && other.getDescription().equals(this.getDescription()))
                && other.getRepeat().equals(this.getRepeat());
    }
```
###### /java/seedu/taskmanager/model/task/ReadOnlyTask.java
``` java
        builder.append(getTitle())
                .append(getStartDate().isPresent() ? " Start Date: " + getStartDate().get() : "")
                .append(getEndDate().isPresent() ? " End Date: " + getEndDate().get() : "")
                .append(getDescription().isPresent() ? " Description: " + getDescription().get() : "")
                .append(getRepeat().isPresent() ? " Repeats: " + getRepeat().get() : "")
                .append(" Status: " + getStatus())
                .append(" Tags: ");
        getTags().forEach(builder::append);
```
###### /java/seedu/taskmanager/model/task/Repeat.java
``` java
/**
 * Represents a Task's repeat pattern in the task manager. Guarantees:
 * immutable; is valid as declared in {@link #isValidRepeat(String)}
 */
public class Repeat {

    public static final String MESSAGE_REPEAT_CONSTRAINTS = "Repeat patterns should be either "
            + "DAY, WEEK, MONTH or YEAR";

    public enum RepeatPattern {
        DAY, WEEK, MONTH, YEAR
    }

    public final RepeatPattern pattern;

    /**
     * Validates given repeat pattern.
     *
     * @throws IllegalValueException
     *             if given repeat pattern string is invalid.
     */
    public Repeat(String repeat) throws IllegalValueException {
        assert repeat != null;
        String trimmedAndUpperCaseRepeat = repeat.trim().toUpperCase();
        this.pattern = toEnum(trimmedAndUpperCaseRepeat);
    }

    /**
     * Returns RepeatPattern enum if a given string is a valid repeat pattern.
     */
    private RepeatPattern toEnum(String trimmedRepeat) throws IllegalValueException {
        switch (trimmedRepeat) {
        case "DAY":
            return RepeatPattern.DAY;
        case "WEEK":
            return RepeatPattern.WEEK;
        case "MONTH":
            return RepeatPattern.MONTH;
        case "YEAR":
            return RepeatPattern.YEAR;
        default:
            throw new IllegalValueException(MESSAGE_REPEAT_CONSTRAINTS);
        }
    }

    @Override
    public String toString() {
        return pattern.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Repeat // instanceof handles nulls
                        && this.pattern.equals(((Repeat) other).pattern)); // state
        // check
    }

    @Override
    public int hashCode() {
        return pattern.hashCode();
    }
}
```
###### /java/seedu/taskmanager/model/task/StartDate.java
``` java
    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy h:mm a");
    private static final SimpleDateFormat sdfOutputForDateString = new SimpleDateFormat("d MMM yyyy");
    private static final SimpleDateFormat sdfInput = new SimpleDateFormat("dd/MM/yyyy");
    private static final SimpleDateFormat sdfOutputForStorage = new SimpleDateFormat("d MMM yyyy h:mm a");

    private static boolean timeInferred;

    /**
     * Validates given start date.
     *
     * @throws IllegalValueException
     *             if given start date is invalid.
     */
    public StartDate(String startDate) throws IllegalValueException {
        super(startDateConstructor(startDate));
    }

    public StartDate(DateTime dt) {
        super(dt.toDate().getTime());
    }

    private static long startDateConstructor(String startDate) throws IllegalValueException {
        try {
            return sdfInput.parse(startDate).getTime();
        } catch (ParseException e) {
            try {
                Parser parser = new Parser();
                List<DateGroup> dateGroups = parser.parse(startDate);
                Date parsedDate = dateGroups.get(0).getDates().get(0);
                timeInferred = dateGroups.get(0).isTimeInferred();
                if (timeInferred) {
                    DateTime dt = new DateTime(parsedDate);
                    dt = dt.withTime(WORKING_HOUR_START);
                    return dt.getMillis();
                }
                return dateGroups.get(0).getDates().get(0).getTime();
            } catch (IndexOutOfBoundsException f) {
                throw new IllegalValueException(MESSAGE_STARTDATE_CONSTRAINTS);
            }
        }
    }
```
###### /java/seedu/taskmanager/model/task/StartDate.java
``` java
    @Override
    public String toString() {
        return sdfOutput.format(this);
    }

    public String toStorageString() {
        return sdfOutputForStorage.format(this);
    }

    public String toDateString() {
        return sdfOutputForDateString.format(this);
    }
```
###### /java/seedu/taskmanager/model/task/StartDate.java
``` java
    public boolean isTimeInferred() {
        return timeInferred;
    }
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    private Optional<StartDate> startDate;
    private Optional<EndDate> endDate;
    private Optional<Description> description;
    private Optional<Repeat> repeat;
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Title title, Optional<StartDate> startDate, Optional<EndDate> endDate,
            Optional<Description> description, Optional<Repeat> repeat, Status status, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(title, endDate, description, tags);
        this.title = title;
        this.startDate = startDate;
        this.endDate = endDate;
        this.description = description;
        this.repeat = repeat;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
        this.status = status;
    }
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    public void setStartDate(Optional<StartDate> startDate) {
        this.startDate = startDate;
    }

    @Override
    public Optional<StartDate> getStartDate() {
        return startDate;
    }

    public void setEndDate(Optional<EndDate> endDate) {
        assert endDate != null;
        this.endDate = endDate;
    }

    @Override
    public Optional<EndDate> getEndDate() {
        return endDate;
    }

    public void setDescription(Optional<Description> description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Optional<Description> getDescription() {
        return description;
    }

    @Override
    public Optional<Repeat> getRepeat() {
        return repeat;
    }

    public void setRepeat(Optional<Repeat> repeat) {
        assert repeat != null;
        this.repeat = repeat;
    }
```
###### /java/seedu/taskmanager/model/task/UniqueTaskList.java
``` java
            if (!t1.getStartDate().isPresent() && !t2.getStartDate().isPresent()) {
                return 0;
            } else if (t1.getStartDate().isPresent()) {
                return -1;
            } else {
                return 1;
            }
```
###### /java/seedu/taskmanager/model/task/UniqueTaskList.java
``` java
            if (!t1.getEndDate().isPresent() && !t2.getEndDate().isPresent()) {
                return 0;
            } else if (t1.getEndDate().isPresent()) {
                return -1;
            } else {
                return 1;
            }
        }
    }
}
```
###### /java/seedu/taskmanager/model/util/SampleDataUtil.java
``` java
            return new Task[] {
                new Task(new Title("Visit Alex Yeoh"), Optional.ofNullable(new StartDate("01/11/2017")),
                        Optional.ofNullable(new EndDate("02/11/2017")),
                        Optional.ofNullable(new Description("His address is Blk 30 Geylang Street 29, #06-40")),
                        Optional.ofNullable(new Repeat("DAY")),
                        new UniqueTagList("social")),
                new Task(new Title("Collect files from boss"), Optional.ofNullable(new StartDate("05/11/2017")),
                        Optional.ofNullable(new EndDate("08/11/2017")),
                        Optional.ofNullable(new Description("Important business files")),
                        Optional.ofNullable(null),
                        new UniqueTagList("colleagues", "business")),
                new Task(new Title("Visit Charlotte Oliveiro"), Optional.ofNullable(new StartDate("20/12/2017")),
                        Optional.ofNullable(new EndDate("20/12/2017")),
                        Optional.ofNullable(new Description("Her address is Blk 11 Ang Mo Kio Street 74, #11-04")),
                        Optional.ofNullable(new Repeat("MONTH")),
                        new UniqueTagList("social")),
                new Task(new Title("Call David Li"), Optional.ofNullable(new StartDate("08/08/2017")),
                        Optional.ofNullable(new EndDate("10/08/2017")),
                        Optional.ofNullable(new Description("his number is 12345678")),
                        Optional.ofNullable(new Repeat("YEAR")),
                        new UniqueTagList("schoolwork")),
                new Task(new Title("Submit project report"), Optional.ofNullable(new StartDate("20/07/2017")),
                        Optional.ofNullable(new EndDate("21/07/2017")),
                        Optional.ofNullable(new Description("Submit to tutor in class")),
                        Optional.ofNullable(null),
                        new UniqueTagList("schoolwork")) };
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
    @XmlElement(required = true)
    private String repeat;
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
        startDate = source.getStartDate().isPresent() ? source.getStartDate().get().toStorageString() : null;
        endDate = source.getEndDate().isPresent() ? source.getEndDate().get().toStorageString() : null;
        description = source.getDescription().isPresent() ? source.getDescription().get().value : null;
        repeat = source.getRepeat().isPresent() ? source.getRepeat().get().toString() : null;
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Title title = new Title(this.title);
        final StartDate startDate = this.startDate == null ? null : new StartDate(this.startDate);
        final EndDate endDate = this.endDate == null ? null : new EndDate(this.endDate);
        final Description description = this.description == null ? null : new Description(this.description);
        final Repeat repeat = this.repeat == null ? null : new Repeat(this.repeat);
        final UniqueTagList tags = new UniqueTagList(taskTags);
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
        return new Task(title, Optional.ofNullable(startDate), Optional.ofNullable(endDate),
                Optional.ofNullable(description), Optional.ofNullable(repeat), status, tags);
    }
```
###### /java/seedu/taskmanager/ui/TaskCard.java
``` java
        startDate.setText(task.getStartDate().isPresent() ? "Starts: " + task.getStartDate().get() : "");
        endDate.setText(task.getEndDate().isPresent() ? "Ends: " + task.getEndDate().get() : "");
        description.setText(task.getDescription().isPresent() ? task.getDescription().get().value : "");
        repeat.setText(task.getRepeat().isPresent() ? "Repeats: " + task.getRepeat().get() : "");
```
###### /java/seedu/taskmanager/ui/TaskListPanel.java
``` java
    private void setConnections(ObservableList<ReadOnlyTask> taskList, boolean isSummary) {
        taskListView.setItems(taskList);
        if (isSummary) {

            // taskListView.setCellFactory(listView -> new TaskListViewCell());
            taskListView.setCellFactory(listView -> new TaskListSummaryViewCell());
        } else {
            taskListView.setCellFactory(listView -> new TaskListViewCell());
            setEventHandlerForSelectionChangeEvent();
        }
    }
```
###### /java/seedu/taskmanager/ui/TaskListPanel.java
``` java
    class TaskListSummaryViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskSummaryCard(task).getRoot());
            }
        }
    }
```
###### /java/seedu/taskmanager/ui/TaskSummaryCard.java
``` java
public class TaskSummaryCard extends UiPart<Region> {

    private static final String FXML = "TaskListSummaryCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label title;
    @FXML
    private Label description;

    public TaskSummaryCard(ReadOnlyTask task) {
        super(FXML);
        title.setText(task.getTitle().value);
        description.setText(task.getDescription().isPresent() ? task.getDescription().get().value : "");
    }
}
```
###### /resources/view/TaskListSummaryCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.111"
	xmlns:fx="http://javafx.com/fxml/1">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>

		<VBox alignment="CENTER_LEFT" minWidth="200.0" minHeight="30.0" HBox.hgrow="ALWAYS">

			<padding>
				<Insets bottom="5" left="10" right="5" top="5" />
			</padding>

			<children>
				<HBox alignment="CENTER_LEFT" spacing="5">
					<children>
						<HBox>
							<Label fx:id="title" styleClass="cell_big_label" text="\$first"
								wrapText="true" />
						</HBox>
					</children>
				</HBox>
				<Label fx:id="description" styleClass="cell_small_label" text="\$description"
					wrapText="true" />
			</children>
		</VBox>

	</children>
</HBox>
```
